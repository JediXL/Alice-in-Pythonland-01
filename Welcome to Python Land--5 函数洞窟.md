# 函数洞窟

![[Pasted image 20221025095007.png]]

Alice来到洞窟门口，点亮手中火把，徐徐向前探索。

## 函数

从标题来看读者们也一目了然我们要开始介绍*函数*了，那么函数是什么呢？听到这个名词最多的场景是数学课，我们经常说一元二次函数、三角函数等等，有时候也会用f(x)表示一个函数形式。通常来说同一类函数具有类似的结构或功能。编程语言中的函数也类似，通常来说，**函数是有组织的、可重复使用的、用于实现某单一功能或关联操作的代码块**。也就是说，我们在使用函数时将一些共性的方法提取出来，使得这一段代码块可以被重复使用。

请看第一个实例。假设我们需要利用已经学过的招数计算某个数的平方，那我们一定可以非常快速地写出，某个数的平方=该数\*该数。

```python 3
a = 3
b = 5
c = 7
d = 9

a = a * a
b = b * b
c = c * c
d = d * d

print(a, b, c, d)
```

其中的共性就是*平方数的计算方法*，因此我们就可以把计算方法抽象出来形成一个函数。以后不管求哪个数的平方，都可以使用该方法。

```python 3
def square(x):
    res = x * x
    return res
```

上述形式就是函数的标准形式。其中def为关键字，紧随其后的square为函数名，( )内的x为输入参数，也就是我们想让这个函数处理的数据，注意这里的括号并不可以省略。return是另一个函数中常用关键字（可省略），用于将程序运行后的某个值返回。

以上我们就已经定义了一个函数，那如何在程序中使用它呢？在《西游记》中，金角大王、银角大王二人拥有宝物*紫金红葫芦*，它的作用就是只要叫上声名字，若其应了，就会被装入葫芦里。函数的调用方法就是“**呼唤他的名字**”，具体如下：

```python 3
def square(x):
    res = x * x
    return res

square(6)
```

我们呼唤了函数名字——square，就可以计算6的平方了。在这里需要额外提醒读者，如果你使用的是交互式编程环境，你输入以上代码运行后编辑器会返回“36”。但如果使用的是文本编程环境，会发现运行代码后没有任何输出。这是因为return虽然把结果返回了，但是并没有被“输出”出来，在交互式编程环境中会自动输出函数的返回值，而文本编程环境中则需要我们手动输出，我们只需要做如下操作，意味着打印该函数的结果即可。

```python 3
def square(x):
    res = x * x
    return res

print(square(6))
```

在Python编程语言中，并不是所有的对象都是“可呼唤”的，这里的可呼唤可以被理解为“可调用”，利用callable方法就能判定该元素是否可被调用，该方法返回True或者False。

```python 3
x = "hello python"
y = 5

print(callable(x))
print(callable(y))
print(callable(square))
————————————————————————
False 
False 
True
```

如上所示，square作为一个函数是可被调用的。在square函数中x是需要传入的参数，是可选项，但是并不意味着所有的输入都合规合法。例如传入的是字符串，由于计算平方本质上是乘法操作，但字符串乘字符串是会报错的，如下所示：

```python 3
x = 'whatever'

square(x)
————————————————
TypeError: can't multiply sequence by non-int of type 'str'
```

所以在进行函数设计时，像设计分支结构一样，我们要考虑程序的*完备性*。此处有两种方法防止用户错误使用平方函数，一种是在函数内部判断输入数据是否合理。以整数平方为例，可以利用if语句判断输入的参数是否为整型，若是整型则进行平方运算，否则输出“参数类型错误”。注意此处的“类型错误”是输出所得，不是系统报错信息。

```python 3
def square(x):
    if type(x) == int:
        res = x * x
        return res
    else:
        print("type error")

square(3)
——————————————————————
9

square('whatever')
——————————————————————
type error
```

在Python 3.x版本后我们可以利用**函数注解**的方法提示用户输入参数和返回参数的类型。只需要在输入参数x的后面跟上\：int，声明x应该是整型，后面的->int表示函数返回的也是一个整型。但是，请读者注意函数注解的作用仅限于**提醒**函数使用人员，而不能规避程序报错。当输入为字符串时，使用了函数注解的程序仍然会触发系统报错。

```python 3
def square(x:int) -> int:
    res = x * x
    return res


square(3)
——————————————————————
9

square('hello')
——————————————————————
TypeError: can't multiply sequence by non-int of type 'str'
```

换言之，函数注解在程序运⾏⽅⾯确实是没用的，它的⽤处在与*编码协作*，也就是别⼈拿到你的代码后，能清晰获知如何使⽤你的代码。

刚才我们介绍的平方函数只接收了一个参数，但是函数是可以接收多个参数的，以最简单的加法为例，就需要两个参数的参与。**多个参数的传入**方式是在括号内以逗号分隔实现的。

```python 3
def add(x, y):
    res = x + y
    return res

add(3, 5)
```

函数同样也可以**返回多个结果**，实现方式是return后使用逗号隔开多个返回值。以之前讲过的除法为例，Python程序设计中可以利用不同的除法方式分别得到正常结果、商数和余数，可以设计一个函数返回除法的三个结果。

```python 3
def divmethod(x, y):
    division = x / y
    division_quotient = x // y
    division_remainder = x % y
    return division, division_quotient, division_remainder

divmethod(7, 2)
```

但是在实际应用场景中，当我们设计一个通用函数后，不知道使用者到底会放入多少个参数，比如上文提到的求和函数，完全有可能3个、5个甚至100个数字求和。因此面对这种**未知参数**或**可变参数**场景，我们可以通过在参数前加\*的方式表明我们的函数可以接受任意参数。在上文提到的求和函数基础上做改进，在输入参数x前加\*，表明接受任意数量参数。但需要注意的，此时所有的输入参数构成了一个“大”变量x，因此在求和时需要对x进行遍历求和。

```python 3
def add(*x):
    res = 0
    for v in x:
        res = res + v
    return res

print(add(1, 2, 3))
```

有的场景我们需要传入的参数间有关联关系，假如要设计一个欠款计算函数，输出每个借款人的名字和借款金额，最后计算借款总额。此时的传入参数之间是有联系的，如张三欠我50元。根据之前的知识，我们已经知道这种关联关系可以通过字典来实现，那函数输入参数时同样也支持**多个参数以字典形式传入**，只需要在传入参数前加上两个\*，表示函数可以接受多个键值对。上述欠款计算函数则通过遍历字典中的键和值把对应欠款打印出来并累加求和返回结果。

```python 3
def debt(**people):   
    sum = 0
    for k, v in people.items():
        print(f'{k} owes me {v}')
        sum += v
    return sum

debt(Spike=20, Tom=30, Jerry=40)
```

## 算法

在前文中，我们曾强调过我们可以使用函数将一些功能共性部分提取出来，这样形成的有组织的代码块就可以被我们重复利用去实现类似的功能。而在生活中解决实际问题的时候，我们也会套用一些现成的解决思路，这些解决问题的思路，在编程过程中我们称之为**算法**，算法一般也写成函数形式，目的是为了方便后续重复使用。

在数学和计算机科学中，一个被定义好的、计算机可施行其指示的有限步骤或次序就被称为算法，常被用于计算、数据处理和自动推理。这个定义对算法进行了更为严谨的解释，但是也晦涩难懂。我们回想一个经典问题“把大象放进冰箱需要几步？”。答案是三步：打开冰箱门、把大象放入冰箱、关上冰箱门。这三个步骤就解决了把大象放进冰箱这个问题，他们就是有顺序的、可执行的指令。因此我们也可以说，*算法就是⼀系列解决问题的可执⾏步骤*。

但是算法是有好坏之分的，如上述算法的执行效果就取决于冰箱是否足够大，一般而言上述算法的执行效果都是较差的。很多算法书或者计算机类书都会用“菜谱”来形象地比喻算法，但是这或许稍有不妥。诚然菜谱是一系列步骤，你按照菜谱来做是可以做出美味佳肴的，但是菜谱本身是不具备可执行性的，如果一定要用做菜这件事来类比算法，那可能智能炒菜机更应该被类比为算法，智能炒菜机可以按照某些可执行步骤帮你做出一道美味佳肴。

由于算法是一系列可执行步骤按照某种顺序排列起来的，因此我们可以用流程图来表示一个算法。一般在流程图表示中，以*椭圆*表示开始和结束，以*菱形*表示判断，以*平行四边形*表示输出。下图所展示的就是一个“打印除最后一位数字”算法的流程图。

![[Pasted image 20221029174928.png|400]]

每个算法所解决的问题可能是不同的，但是设计算法时有几种比较通用的思想或套路，掌握这些套路可以帮助你更快地写出解决相应问题的算法。

### 枚举法

首先请大家玩一个简易版的“明星大侦探”，其中有4个参与玩家，A说“我不是凶手”，B说“C是凶手”，C说“D是凶手”，D说“C在说谎“，在这四个人之中只有一个真凶，只有真凶可以说谎，请写一个函数判断谁是真凶。

在不考虑高阶解法的情况下，要解决这个问题，无非就是去列举出来这个问题中的所有情况，也就是每个人无非两种角色“好人”或者“真凶”，对列举出来的所有情况逐个试验，最终找出符合题目要求的这一种情况。

```python 3
num_bad = 1
num_liar = 1

def detective(num_bad, num_liar, **players):
    roles = ['good', 'bad']
    for A in range(2):
        for B in range(2):
            for C in range(2):
                for D in range(2):
                    con_bad = ((A+B+C+D) == num_bad)
                    st_A = int(eval(players['A']))
                    st_B = int(eval(players['B']))
                    st_C = int(eval(players['C']))
                    st_D = int(eval(players['D']))
                    con_liar = (st_A + st_B + st_C + st_D) == (len(players) - num_liar)
                    if con_bad and con_liar:
                        res = f'A is {roles[A]}, B is {roles[B]}, C is {roles[C]}, D is {roles[D]}'
                        return res
    print("No idea")
  
# 0 is good, 1 is bad.
detective(num_bad, num_liar, A='A==0', B='C==1', C='D==1', D='D==0')
```

我们在程序最开始声明了真凶和撒谎者的数量，然后写了一个侦探函数，利用枚举方法找出真凶。这里的函数就像是*程序中的一个子程序*。读者们可以发现我们使用了4个for遍历对所有情况进行枚举，A是（0,1）中的任一个，即采用‘0’和‘1’来分别代指好人和真凶。

在对题目进行复述的环节，我们把角色和角色的描述作为字典的键值对成为函数的输入参数，有读者会疑惑，那这里输入的时候为什么不直接写'A = 0'而要写作'A == 0'呢？

因为我们要对输入条件（玩家陈述的语句）进行转换，然后再和当前的枚举情况进行比较，那怎样把玩家陈述的语句进行转换呢？函数中我们使用了*eval( )* 方法，这个函数可以执行一个字符串表达式，并返回表达式的值。例如A = 0时，A == 0利用eval方法输出为True，经过整型转换后得到1。这就成功地把玩家描述语句转换成了数字。然后就可以利用条件中的数学关系（真凶只有1个，谎言只有1个）进行比较了。

con_liar和con_bad就是用来判断是否符合条件的判断变量，con_bad判断(A+B+C+D)的值是否等于num_bad，con_liar判断描述语句(st_A + st_B + st_C + st_D)的值是否等于(len(players) - num_liar)(说真话的人数)，如果这两种情况都满足，则把这种情况输出即可。

如果你面对的实际问题情况比较少，则可以使用枚举法进行求解，该算法不适用于解空间较大的问题。

### 迭代法

在介绍迭代法之前，我们来了解一个哲学概念“*阿基里斯悖论*”：

>公元前5世纪，芝诺发表了著名的阿基里斯悖论：他提出让乌龟在阿基里斯前面1000米处开始，和阿基里斯赛跑，并且假定阿基里斯的速度是乌龟的10倍。当比赛开始后，若阿基里斯跑了1000米，设所用的时间为t，此时乌龟便领先他100米；当阿基里斯跑完下一个100米时，他所用的时间为t/10，乌龟仍然前于他10米；当阿基里斯跑完下一个10米时，他所用的时间为t/100，乌龟仍然前于他1米…… **芝诺认为，阿基里斯能够继续逼近乌龟，但决不可能追上它**。

阿基里斯悖论分离了运动与静止，夸大了相对静止，而否认了绝对运动。抛开哲学问题，这是一个简单的**追及问题**。假设乌龟领先阿基里斯100米，乌龟速度2m/s，阿基里斯速度10m/s，请写一个算法判断什么时候阿基里斯可以追上这只乌龟。请读者注意题目中所给的100，2，10即为我们设计函数时的所需输入。

```python 3
T_speed = 2
T_loc = 100
A_loc = 0
A_speed = 10

def A_T(T_speed, T_loc, A_loc, A_speed):
    if A_speed <= T_speed:
        return False
    time = 0
    while True:
        time += 1
        T_loc += T_speed
        A_loc += A_speed
        if A_loc >= T_loc:
            break
    return time

time = A_T(T_speed, T_loc, A_loc, A_speed)
if time:
    print(f"Achilles can catch the Tortoise within {time}s")
else:
    print('Never')
```

当然可以利用追及问题的数学求解方法编写该算法，抛开数学层面，即使不会使用数学方法，我们仍然可以编写程序解决该问题。在程序的一开始我们可以进行判断，因为是乌龟领先阿基里斯，如果阿基里斯的速度小于乌龟的速度，那阿基里斯的确永远也追不上乌龟，所以我们可以先行判断二者的速度。

在确认了阿基里斯可以追上乌龟之后，先初始化时间为0，然后随着时间的推移去判定二者的位置，当阿基里斯的位置超过乌龟的位置后则返回当前时间，需要注意的是该程序并不能求得精确超越时间。我们在while循环中让计算机对一组指令或一定步骤进行重复执行，每次执行都更新其中的变量值的方法就是**迭代法**。

### 递归法

大家在中学数学中应该了解过*阶乘*这个概念：$n! = n*(n-1)*(n-2)*...*2*1$，要利用函数求得n的阶乘，首先我们可以利用for语句遍历完成这个程序：

```python 3
def fact(n):
    res = 1
    for i in range(1, n + 1):
        res = res * i
    return res

fact(3)
```

但我们也可以把上述阶乘形式写为：$n! = n*(n-1)!$。因此我们发现要想求n的阶乘，可以先求得n-1的阶乘，要想求n-1的阶乘，可以求n-2的阶乘……好像我们可以反向推导求得任意一个数的阶乘，请注意0的阶乘等于1。

```python 3
def fact(n):
    if n == 0:
        return 1
    else:
        return n * fact(n-1)

fact(3)
```

在这个求解过程（函数）中，我们发现求n的阶乘又调用了fact(n-1)，这种*函数定义中有直接（或间接）调用自身的一种方法*就称之为**递归法**。递归法可以把一个大型复杂问题转化为一个与原问题相似的规模较小的问题，递归不如迭代或遍历逻辑简单，但是递归方法的代码量一般较少。

在使用递归方法时，首先应该掌握的**最简单结论**，比如0的阶乘等于1，其次应该提取其中的**规则**，如$n! = n*(n-1)!$。这是在设计递归算法时的关键要素。递归程序编写时对最简单结论进行判断，否则进入规则将问题简化至最简单结论。

## 命名空间

在之前的内容中，我们直接为一个变量取名赋值，为一个函数取名并呼唤他，这种*名称和对象之间的映射关系*就是**命名空间**（Namespace）。在具体讲解命名空间之前，请各位读者判断以下四段代码的输出分别是什么：

```python 3
def f():
    x = 3 
    print(x)
f()
```

```python 3
def f1():
    x = 3 
    def f2():
        x = 4 
        print(x)
    f2()
f1()
```

```python 3
x = 2 
def f():
    x = 3
    print(x)
f()
print(x)
```

```python 3
print(dict)
```

前三段代码x所处的位置不同导致最后输出结果有差异，最后一个dict是Python关键字。在揭晓输出之前，我们以计算机内的文件存储系统为例，在同一个文件夹下，不能有两个文件夹或文件具有一样的名字；在不同的文件夹下，文件名可以相同，这时相同的名字可以对应到不同的文件且互不影响。这里提到的一个个文件夹就类似于一个个*命名空间*。

与命名空间所对应的另一个概念是**作用域**。从字面意义上来讲，作用域就是变量起作用的区域，作用域实际上是命名空间的可见范围。仍以计算机文件存储系统为例，文件夹的范围就被称作*作用域*，A文件夹下有个名叫123的文件，去B文件夹下搜索是无法搜索到的，更无法在B文件夹内对其进行操作，原因就是123这个名字只有在A文件夹下才有意义。这就像我们上学时期班中红人都会有对应的外号，在自己班内叫这个外号大家都知道是谁，但是给其他班或其他学校的同学说这个外号，可能别人就无法理解了。

再来看以上四段代码，第一段代码中x在f这个命名空间内部，称之为**局部对象**（**Local**），x此时等于3。第二段代码中，f2是f1的内部函数，f1是f2的上层命名空间，在上层命名空间命名的对象叫**闭包对象**（**Enclosing**），在f1函数执行后，x=3，然后执行f2函数，此时x被赋值为4并且输出。

第三段代码中，我们在最外部定义了x，这就像在根目录下定义了一个对象，这种对象称之为**全局对象**（**Global**），在其层级之下的所有函数都可以访问他，在f函数执行后x=3并进行输出，值得注意的是，此时在f函数外再次print(x)会发现x=2，其原因是函数内部命名空间对x的作用域仅限于函数内部，因此在最外层进行print时会找和他同层级的x进行输出。

    请读者考虑若此时x为一个容器会有什么样的结果？（涉及上一章的拷贝内容）

我们对第二段代码（闭包对象）进行修改后输出，读者会发现第二个print(x)的结果是x=3，原因就是此时print(x)会找和他同层级的x进行输出。

```python 3
def f1():
    x = 3 
    def f2():
        x = 4 
        print(x)
    f2()
    print(x)
f1()

————————————————————
4
3
```

在最后一段代码中，根据我们已经学过的知识，dict是Python的关键字，就像是计算机系统BIOS中的信息，这种对象属于**内建对象**（**Built-in**）。

读者们可能会疑惑那当我呼唤一个对象名字的时候，到底谈论的是哪个名字呢？如上文提到的多个x，我们如何判断print(x)的时候打印的是哪个x呢？这就要遵循**LEGB规则**了。

![[Pasted image 20221101105300.png|300]]

具体来说LEGB规则是**Local-Enclosing-Global-Builtin**的缩写，是用来规定命名空间查找顺序的规则。如下代码可以帮助读者理解查找顺序。当如下代码执行时，f2中的print(a)会寻找a等于多少，此时f2中有一个Local对象a=2，则输出2。若此时将a=2注释掉，则print(a)向上寻找到f1中的Enclosing对象a=1，则输出1。若再将a=1注释掉，则print(a)继续向上寻找到Global对象a=0，则输出0。若再将a=0注释掉，由于a本身并不是Python的内建变量，因此会报错，报错信息为“name 'a' is not defined”。

```python 3
a = 0

def f1():
    a = 1
    
    def f2():
        a = 2
        print(a)
    f2()
f1()
```

在上文运行如下代码时我们强调，当第二个print(x)运行时会寻找同等级的x，即x=2，也就是说，我们在函数f内部对局部对象x进行操作和修改时并没有影响到全局对象x，因此即使函数内部x被赋予了3，在外部进行第二个print(x)时x仍然等于2。

```python 3
x = 2 
def f():
    x = 3
    print(x)
f()
print(x)
```

那如果一定要在*局部空间内修改全局对象*，我们可以使用**global方法**。运行如下代码可以发现即使第三个print(x)寻找到了同层级的全局对象x，但是因为我们使用了global方法，在函数f内部对全局对象进行了修改，因此最终输出的结果是x=6。

```python 3
x = 5
def f():
    global x
    print(x)
    x = 6
    print(x)
f()
print(x)
——————————————————
5
6
6
```

在日常生活中，有时女孩子会给自己的玩偶起名字，如TGA 2021（The Game Awards 2021）上荣获“年度游戏”奖项的《It takes two》（中文译名《双人成行》）中小女孩罗斯就给自己玩偶取了对应的名字。那我们为什么需要名字呢？维特根斯坦这样解释道：

>命名就像给一件东西贴上标签……我们给事物命名，然后我们就可以**谈论**事物；在谈论中**指涉**它们。

我们只有需要对一个事物进行谈论，进行反复指涉的时候才需要对它进行命名。函数也是一样，只有需要反复呼唤调用时才需要命名，相应地，如果不需要多次呼唤，则可以不对它进行命名。

### 匿名函数

当一个函数不需要被多次调用时，我们可以使用**匿名函数**来实现对应的功能。匿名函数如下所示：

```python 3
(lambda x: x*2) (6)

——————————————————————
12
```

该函数实现的功能等同于：

```python 3
def f(x):
    return x * 2

f(6)
```

匿名函数是由**关键字lambda**引导的，冒号前面的x表示**函数参数**，冒号后紧跟一个**参数处理的表达式**，需要注意的是匿名函数只能有一个参数处理的表达式。匿名函数不需要return，会自动返回结果，返回值为该表达式结果。使用匿名函数的关键是简单、一次性。一次性已经强调过，简单主要体现在必须是一句表达式能够处理的。

那现在请读者练习一下，请写一个函数实现如下功能：找出列表中大于100的所有数组成新列表并返回。利用传统方法读者应该能比较轻易地写出如下函数：

```python 3
nums = [1000, 90, 45, 69, 23, 345, 23, 9, 456]

def greater(l):
    res = []
    for item in l:
        if item > 100:
            res.append(item)
    return res 

greater(nums)
```

此时我们就发现了使用匿名函数的一个难点，因为这个题中要求的是对一个列表进行判断和处理，判断条件虽然简单，但是由于列表中到底有多少个元素我们并不知道。但是列表是一个*可迭代对象*，因此可以利用其他函数和匿名函数进行组合，打一套组合拳来达到目标。

常见组合拳好搭档有**filter函数**和**map函数**。**filter( )** 函数用于*过滤序列*，可以过滤掉不符合条件的元素，并且返回一个可迭代对象，如果需要转换成列表，可以使用list( )进行转换。我们再次回顾刚才的练习题，实质上我们是要将小于100的元素都过滤掉，因此结合filter函数和匿名函数的实现方法如下：

```python 3
nums = [1000, 90, 45, 69, 23, 345, 23, 9, 456]

res = filter(lambda x: x > 100, nums) 
print(list(res))
```

filter函数的标准形式为filter(function, iterable)，其中有两个参数，*第一个为函数，第二个为可迭代对象*。具体的操作过程是，将可迭代对象中的元素作为参数传递给前面的函数进行判断，将返回True的元素放入新迭代器。具体来说，对nums列表作为参数传递给匿名函数进行判断，匿名函数的判断规则是该数大于100，将返回True的元素（大于100的数）赋予res这个可迭代器，由于需要输出的是列表，因此输出时对res进行列表转换。

map函数的标准形式为map(function, iterable, ...)，第一个仍然为函数，其余为一个或多个为可迭代对象。*map函数会根据提供的函数对指定可迭代对象做映射*，因此map函数中有几个可迭代对象取决于匿名函数需要几个参数。假如我们要对某一个列表中的所有元素除以1000并返回新列表，此时映射规则就是对原元素除以1000，利用map函数和匿名函数可按如下方式实现：

```python 3
nums = [1000, 90, 45, 69, 23, 345, 23, 9, 456]

res = map(lambda x: x / 1000, nums) 
print(list(res))
```

若要利用map函数和匿名函数实现两个列表相加的功能并返回新列表，可按如下方法实现：

```python 3
nums = [1000, 90, 45, 69, 23, 345, 23, 9, 456]
nums2 = [1, 2, 3, 4, 5, 6, 7, 8, 9]

res = map(lambda x, y: x + y, nums, nums2) 
print(list(res))
```

此时的匿名函数需要输入的参数是x和y，表达式为x + y，对于map函数而言，此时的映射规则就是匿名函数功能（相加），相应的输入就是两个列表。

## 装饰器

在实际生产生活中我们常常需要输出现在的时间，这个功能可以利用datatime包中的datetime.now方法实现，实现方法也很简单，直接print就可以，换言之，我们在每一个需要输出当前时间的函数里添加这样的语句就可以打印时间了。

```python 3
import datetime

def f():
    print(datetime.datetime.now())
    print('Hello, Alice')

f()
————————————————————————————————————
2022-11-01 11:25:49.827141 
Hello, Alice
```

但显然这样的做法非常不Pythonic，如果需要这个功能的函数很多，这种“复制粘贴”式的方法会带来非常大的工作量，可能编写代码时可以Ctrl C，Ctrl V快速实现，但是在后期运营维护时会非常痛苦。经典的解决方法就是**把这一部分实现共同功能的共享代码放在一个函数中，然后再根据需要调用这个函数即可**。

在前文中我们已经体会过了在函数内部嵌套函数的结构，在介绍装饰器之前需要跟读者强调两点：

1、**函数可以取函数作为参数**，形如f1(func)即表示函数f1的输入参数为一个函数，当一个函数作为参数传递到函数f1时，f1可以调用所传入的函数对象。

```python 3
def f1(func):
    
```

2、**可以从函数返回一个函数**，若在某个函数的内部return另一个函数，则在函数执行时就可以返回另一个函数的结果。
```python 3
def f1():
    return f2()
```

利用上述的第二点我们就可以完成刚才打印时间的任务：

```python 3
import datetime

def f1():
    print(datetime.datetime.now())
    return f2()

def f2():
    print('Hello, Alice')

f1()
————————————————————————————————————
2022-11-01 11:25:49.827141 
Hello, Alice
```

在程序运行阶段，运行f1，执行打印时间语句，然后返回f2，此时运行f2，打印Hello, Alice，得到如上结果。在这个程序中，我们将打印时间这样一个共性功能写为一个函数，将打印语句写为一个函数，通过return 函数这样的方法实现了用打印时间函数装饰原函数的目的。这就实现了**函数装饰器**的作用，**函数装饰器允许用额外的函数增强现有函数，而不需要改变现有函数的代码**。

需要强调的是：1、*装饰器本身也是个函数*，只不过它执行的功能是管理一个现有函数，我们把现有的函数称为被装饰函数。2、*装饰器需要接收被装饰函数为参数*，这可以清晰地表示装饰器的装饰对象是谁。3、*装饰器会返回一个新函数作为其返回值*。4、*装饰器确保返回的函数与被装饰函数有同样的参数个数和类型*，函数参数的个数和类型称为函数的签名，因此装饰器会维护被装饰函数的签名。

我们按照这几个规则重新实现上述功能：

```python 3
import datetime


def f1(func):
    def wrapper():
        print(datetime.datetime.now())
        return func()
    return wrapper


def f2():
    print('Hello, Alice')


f3 = f1(f2) 
f3() 

————————————————————
2022-11-01 11:25:49.827141 
Hello, Alice
```

在这个实现过程中我们可以发现装饰器f1以某一个函数为输入参数，最终返回一个装饰函数，在装饰器中嵌套的装饰函数则主要执行装饰功能，此处功能为打印时间。我们令f3等于f1(f2)表示用f1这个装饰器装饰函数f2，并执行f3()。

我们注意到这里的被装饰函数没有参数，只是固定的输出了Hello, Alice，假设我们要求被装饰函数带有参数name，输出任意的Hello, \{name\}，则可以将上述程序进行改进。

```python 3
import datetime


def f1(func):
    def wrapper(*args, **kw):
        print(datetime.datetime.now())
        return func(*args, **kw)
    return wrapper

def f2(name):
    print(f'Hello, {name}')


f3 = f1(f2)
f3('Tom') 

————————————————————
2022-11-04 14:11:04.754531 
Hello, Tom
```

与上文的区别在于，我们首先对被装饰函数f2进行了修改，使他具备一个传入参数name，并且打印Hello, \{name\}（根据输入的参数进行打印）。在装饰器部分，为了使*装饰器返回的函数与被装饰函数有同样的参数个数和类型*，我们对装饰函数wrapper的参数进行了修改，利用前文讲过的\*和\*\*方法，保证创建的装饰函数**能够接收任意数量和类型的参数**。注意(\*args, \*\*kw)是一种约定俗成的固定写法。我们仍然令f3等于f1(f2)表示用f1这个装饰器装饰函数f2，并执行f3('Tom')，表示此时我们传入的变量是Tom。

但是每次都要令一个新函数来表示用某个装饰器装饰某个函数就非常麻烦。因此，我们可以利用Python语言中的**语法糖**（Syntactic Sugar）来帮我们快速完成这个任务。*语法糖就是一些好看、好记、也好用的“快捷方式”*，例如我们提过的列表推导式、匿名函数等都属于Python语言中的语法糖，在这里我们需要用到Python装饰器语法糖：**\@**

```python 3
import datetime

def f1(func):
    def wrapper(*args, **kw):
        print(datetime.datetime.now())
        return func(*args, **kw)
    return wrapper

@f1 
def f2(name):
    print(f'Hello, {name}')
 
f2('Tom')
```

我们对之前的代码进行了改进，会发现最大的不同就是不再新创建f3来表示修饰关系，而是直接使用\@f1，直接表示用f1装饰f2。糖虽然甜，但是会有副作用。如果此时我们打印函数f2的函数名，会发现如下情况：

```python 3
import datetime

def f1(func):
    def wrapper(*args, **kw):
        print(datetime.datetime.now())
        return func(*args, **kw)
    return wrapper

@f1 
def f2(name):
    print(f'Hello, {name}')
 
f2('Tom')
print(f2.__name__)

————————————————————————————————
2022-11-04 14:24:15.007456 
Hello, Tom 
wrapper
```

我们发现经过装饰后的f2穿上了马甲，我们还就真不认识它了，函数f2的名字已经变了，变成了包装它的函数名。本质上\@f1等价于f2 = f1(f2)，所以f2的函数名会被修改，如此包装我们或许不能接受，于是我们就要请专业的工具来帮助我们实现，这就是functools中的wraps方法。

```python 3
import datetime
from functools import wraps

def f1(func):
    @wraps(func)
    def wrapper(*args, **kw):
        print(datetime.datetime.now())
        return func(*args, **kw)
    return wrapper

@f1 
def f2(name):
    print(f'Hello, {name}')
 
f2('Jerry')
print(f2.__name__)

————————————————————————————————
2022-11-04 14:29:14.554919 
Hello, Jerry 
f2
```

我们在装饰器一开始添加了\@wraps(func)，就告诉系统接下来的内容就是要对被装饰函数进行包装了，系统就会保留被装饰函数的原始信息。

在户外运动时我们经常需要多层穿搭，每层穿搭都有自己的功能，同样我们在装饰器使用过程中，也*可以使用多个装饰器对被装饰函数进行包装*。这也提醒我们在设计装饰器功能时*不要*把所有功能都写到一个装饰器里，这同样不利于我们后期对程序进行维护和调整。

```python 3
def f1(func):
    @wraps(func)
    def wrapper(*args, **kw):
        print("f1")
        return func(*args, **kw)
    return wrapper


def f2(func):
    @wraps(func)
    def wrapper(*args, **kw):
        print("f2")
        return func(*args, **kw)
    return wrapper


def f3(func):
    @wraps(func)
    def wrapper(*args, **kw):
        print("f3")
        return func(*args, **kw)
    return wrapper

  
@f1
@f2
@f3
def f():
    print("hello")


f() 

————————————————————————————
f1 
f2 
f3 
hello
```

这里定义了三个装饰器用来装饰函数f，虽然他们实现的功能都比较简单，这里实际运行的f( )，等价于f1(f2(f3(f())))。装饰器是Python的高阶技巧之一，也是Python语言中的一个大杀器，可能读者们在刚开始并不知如何下手，那只需要“照猫画虎”，对照上文例子，总结出其中不变的地方为模板，实现具体功能的地方（如打印时间）为可变内容，按需填入自己想要实现的功能即可。

## 练习

### 回文检测

有一部名为《降临》的科幻电影，是根据科幻小说《你一生的故事》改编的，在这部电影中有一个角色名为Hannnah，这种名字的形式我们称之为“回文”，常见的中文回文有“上海自来水来自海上”、“王中王”等。回文的判断标准是正反写结果一致。请你设计一个函数，判断用户的输入是否为回文。

### 求第n个斐波那契数

斐波那契数列由0和1开始，之后的斐波那契数就是由之前的两数相加而得出，请设计函数输出第n个斐波那契数。

### 装饰累加器

实现一个累加函数（输入为n，返回n到1的累加）；实现一个装饰器， 把函数的返回值+100然后返回；将上述装饰器应用于累加器之上。

## 练习解析

回文检测的练习题较为简单，其关键是判断**翻转输出是否相同**，可以从首位开始和尾位逐位比较。这里推荐利用之前学过字符串切片方法，得到输入的反向结果，直接和输入进行比较，若相同则为回文，反之则不是回文。

```python 3
words = input("please input: ")

def checkPalindrome(words):
    words = words.lower()
    return words == words[::-1]

checkPalindrome(words)
```

在练习斐波那契数的递归实现方法时读者应该注意递归方法的适用范围，当一个问题无法正向推导，或利用反向推演更适合求解时，应该优先考虑递归方法。在递归应用过程中应该注意对两个部分进行提炼：**最简单结论**和**规则**。以斐波那契数为例，最简单结论是前两个数都等于1，规则是当前数等于前两个数的累加和。按照如上思想，读者应该能够完成该练习题。

```python 3
def fib(n):
    if n == 1:
        return 1
    elif n == 2:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)
```

在累加器的实现过程中，可以使用*数学方式*实现，也可以使用*迭代方式*实现，这两种情况都相对简单，然后套用装饰器的模板即可完成相应目标。

```python 3
from functools import wraps

def add_one_hundred(func):
    @wraps(func)
    def wrapper(*args, **kw):
        return func(*args, **kw) + 100
    return wrapper

@add_one_hundred
def accumulation(n : int):
    return ((n + 1) * n) / 2

accumulation(2)
```

当然累加器还可以使用递归方法实现，但是会发现如下问题：因为累加器是递归的，需要调用很多次累加器函数，此时每次调用都会有一个装饰器来装饰他，所以最后的结果会多加很多个100。那如果一定要使用递归怎么办呢？此时我们就需要对装饰器进行限制了，由于只需要调用一次装饰器，所以可以设定一个“标志位”——is_first。当然更完美的方法是使用*带参数的装饰器*，本书不再赘述。

```python 3
from functools import wraps

is_first = True

def add_one_hundred(func):
    @wraps(func)
    def wrapper(*args, **kw):
        global is_first
        if is_first:
            is_first = False
            return func(*args, **kw) + 100
        else:
            return func(*args, **kw)
    return wrapper

@add_one_hundred
def accumulation(n : int):
    if n == 1:
        return 1
    else:
        return n + accumulation(n-1)

accumulation(4)
```